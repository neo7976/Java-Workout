## Настойчивый жук.

Напишите функцию , persistenceкоторая принимает положительный параметр numи возвращает его мультипликативную постоянство, то есть количество раз, которое вы должны умножить на цифры num, пока не получите одну цифру.

Например **(Ввод --> Вывод):**

```
39 --> 3 (because 3*9 = 27, 2*7 = 14, 1*4 = 4 and 4 has only one digit)
999 --> 4 (because 9*9*9 = 729, 7*2*9 = 126, 1*2*6 = 12, and finally 1*2 = 2)
4 --> 0 (because 4 is already a one-digit number)
```

## Возьмите число и просуммируйте его цифры, возведенные в последовательные степени, и ....¡Эврика!!

Число `89`— это первое целое число, состоящее более чем из одной цифры, которое удовлетворяет свойству, частично 
представленному в названии этого ката. Что толку говорить "Эврика"? Потому что эта сумма дает одно и то же число.

В результате: `89 = 8^1 + 9^2`

Следующим числом обладающего этим свойством является 135.

Посмотрите это свойство еще раз: `135 = 1^1 + 3^2 + 5^3`

Нам нужна функция для сбора этих чисел, которая может принимать два целых числа `[a, b]` которая определяет диапазон
`[a, b]`(включительно) и выводит список отсортированных чисел в диапазоне, удовлетворяющем описанному выше свойству.

**Давайте посмотрим на некоторые случаи (ввод -> вывод):**

```
1, 10 -> [1, 2, 3, 4, 5, 6, 7, 8, 9]

1, 100 -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 89]
```
Если в диапазоне `[a, b]` таких чисел нет, функция должна вывести пустой список.
```

90, 100 --> []
```
Наслаждайся этим!!

## Равные стороны массива

Вам будет дан массив целых чисел. Ваша задача состоит в том, чтобы взять этот массив и найти индекс N, где сумма целых
чисел слева от N равна сумме целых чисел справа от N. Если такого индекса нет, верните `-1`.

Например:

- Допустим, вам дан массив `{1,2,3,4,3,2,1}`:
ваша функция вернет индекс 3, потому что в 3-й позиции массива сумма левой части индекса ( `{1,2,3}`) и сумма правой 
части индекса ( `{3,2,1}`) равны `6`.

- Давайте посмотрим на другой.
Вам дан массив `{1,100,50,-51,1,1}`:
ваша функция вернет индекс 1, потому что в 1-й позиции массива сумма левой части индекса ( `{1}`) и сумма правой части
индекса ( `{50,-51,1,1}`) равны `1`.

- Последний:
вам дан массив. `{20,10,-80,10,10,15,35}`
В индексе 0 левая сторона равна `{}`
Правая сторона равна `{10,-80,10,10,15,35}`
Они обе равны `0` при добавлении. (Пустые массивы равны 0 в этой задаче)
Индекс 0 - это место, где левая и правая части равны.

**Примечание.** Помните, что в большинстве языков программирования/скриптов индекс массива начинается с 0.

**Вход:**
Целочисленный массив длины 0 < arr < 1000. Числа в массиве могут быть любыми целыми положительными или отрицательными.

**Выход:**
наименьший индекс N, в котором сторона слева от Nравна стороне справа от N. Если вы не найдете индекс, соответствующий 
этим правилам, вы вернете -1.

**Примечание.**
Если вам дан массив с несколькими ответами, верните наименьший правильный индекс.

## Очередь в супермаркет
В супермаркете очередь к кассам самообслуживания. Ваша задача — написать функцию для расчета общего времени, необходимого всем покупателям для оформления заказа!

**Вход**
- клиенты: массив положительных целых чисел, представляющих очередь. Каждое целое число представляет покупателя, а его значение — количество времени, которое ему требуется для оформления заказа.
- n: положительное целое число, количество касс.

**Выход**
Функция должна возвращать целое число — общее требуемое время.

**Важный**
Пожалуйста, ознакомьтесь с примерами и пояснениями ниже, чтобы убедиться, что вы правильно поняли задачу :)

**Примеры**
```java
queueTime([5,3,4], 1)
// should return 12
// because when there is 1 till, the total time is just the sum of the times

queueTime([10,2,3,3], 2)
// should return 10
// because here n=2 and the 2nd, 3rd, and 4th people in the
// queue finish before the 1st person has finished.

queueTime([2,3,10], 2)
// should return 12
```
**Уточнения**
- Существует только ОДНА очередь, обслуживающая множество касс, и
- Порядок очереди НИКОГДА не меняется, и
- Первый человек в очереди (то есть первый элемент в массиве/списке) переходит к кассе, как только она освобождается.

NB Вы должны исходить из того, что все входные данные теста будут действительными, как указано выше.

PS Ситуацию в этом ката можно сравнить с идеей пула потоков, более связанной с информатикой, в отношении одновременного запуска нескольких процессов: https://en.wikipedia.org/wiki/Thread_pool